---
output:
  html_document:
    fig_caption: yes
    theme: united
    toc: yes
---
***

# Fitting a 2PL IRT Model in Stan
## Load Packages 

First we load the packages
```{r packages, results="hide",message=FALSE}
library(knitr)
library(rstan)
library(ggplot2)
library(plyr)
library(reshape2)
library(parallel)
```
Then we set the random-number generator seed in order to make the results reproducible
```{r}
set.seed(42)
```

##Specify Model

In a IRT model, the probability of generating a particular response   $\; y_{jk}$  can be viewed as driven by the interaction of the characteristics of the person and the characteristics of the item. For example, for person $j$ and test item $k$, a latent trait (e.g. ability) represented by $\; \theta_j$, interact with _item discrimination_ parameters, represented by $\; \alpha_k$, and an _item intercept_ parameter $\; \beta_k$ to determine the probability of correct response. If we divide the intercept $\; \beta_k$ by $\; \alpha_k$ and flip its sign, $\beta_k$  can be interperted as item difficulty. 

Let $\; y_{jk} \vert \pi_{jk}\sim Bernoulli \left(\pi_{jk} \right)$ such that $E(y_{jk} )=\pi_{jk}$. The 2PL model specifies that the mean expected response
$$
\pi_{jk} = logit^{-1}\Bigl(\alpha^{\intercal}_{k}\theta_{p}+\beta_{k} \Bigr) = {\Bigl(1 + \operatorname{exp}\bigl(-\left( \alpha^{\intercal}_{k}\theta_{p}+\beta_{k}\right)\bigr)\Bigr)}^{-1}
$$
Accordingly, the sampling distribution for each response $jk$ is 
$$
\begin{align}
p(y_{jk}\vert\theta_p,\alpha_p,\beta_i)= {\biggl[logit^{-1}\Bigl(\alpha^{\intercal}_{k}\theta_{p}+\beta_{k} \Bigr)\biggr]}^{y_{jk}} {\biggl[1 - logit^{-1}\Bigl(\alpha^{\intercal}_{k}\theta_{p}+\beta_{k} \Bigr)\biggr]}^{1-y_{jk}}
\end{align} 
$$

##Simulate Data
It is good practice to generate the data in order to examine how well your method of estimation can retireve the ground truth. We now specify the number of items, *K*, and the number of persons *J* we would like to have in our simulated test data and generate the  *true*  parameter values for the item charactersitics vectors  _alpha_ and _beta_ and the person characteristic vector  _theta_, all of which go as inputs in the data model (i.e. the 2PL Item Respone Model). 
```{r preprocess}
K <- 25 # Items
J <- 300 #Person
N <- K*J  #observations
alpha     <- runif(K,.5,2) #slopes
beta     <- runif(K,-2,3) # intercepts
data.frame(alpha,beta)
theta.mu <- 0 # population mean of person ability
theta.sig <- 1 # population sd of  person ability
theta  <- rnorm(J,theta.mu,theta.sig) # generate 500 ability parameters
head(theta)
```
Now we are ready to generate the K x J matrix of response probabilities
```{r}
slope.ability  <- outer(theta, alpha) # multiply the slope vector by the ability vector
intercept      <- matrix(rep(beta, J), nrow=J, byrow=TRUE)
Prob           <- plogis(intercept+slope.ability ) # 1/(1 + exp(.))
data           <- ifelse(runif(N) < Prob,1,0) # generate matrix of Bernoulli 0-1 responses
```
The Stan model I wrote expects data in long format, so first we need to reshape the data. While we are at it, lets add an additional column of correct response probabilites so that we can plot the probability frequencies for some items. 

```{r}
df<-melt(data)
colnames(df)<-c("Person","Item","Response")
df$Probability<-c(Prob) # vectorize the matrix and add as a new column
colnames(df)<-c("Person","Item","Response","Probability")
df<-arrange(df, Person) # sort by person
head(df)
```
Here is a plot of the distributions of the probabilities for 5 items:
```{r,fig.width=8, fig.height=6}
ggplot(subset(df,Item %in%  c(1,2,15,24,25))) + geom_density(aes(x = Probability , colour = as.factor(Item)))+ scale_colour_discrete(name="Item")
```

##Fit Model

The follwing lines of code fit a hierarchical Bayesian 2PL model with a unidimensional latent trait (i.e. ability) using Stan
```{r,results="hide"}
source("stan.R") # load code to have Stan run multiple cores in parallel 
y <- df$Response
jj<-df$Person
kk<-df$Item
irt.data<-list(J=J,K=K,N=N,jj=jj,kk=kk,y=y)
Nchains<-4
Niter<-500
model.fit<- stan("2PL.stan", data = irt.data, chains =Nchains, iter=Niter)
save.image()
```



#### To explore the results,  click here https://rfarouni.shinyapps.io/BayesianIRT/.  
***


This webpage was created using the *R Markdown* authoring format and was generated using *knitr* dynamic report engine. The linked webpage hosts an interactive web application automatically generated by *shinyStan*. The shinyStan object was deployed using the *shinyapps.io* framework.

***










